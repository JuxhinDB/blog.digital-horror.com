
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head>
        <title>Digital Horror</title>
        <meta name="description" content="An introductory post that shows how I've gone about implementing a rudimentary broadcast event bus using tokio in order to build a module system with message passing.">
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Load light and dark themes for syntax highlighting -->
<link id="prism-light-theme" href="/themes/prism-theme-github-light.css" rel="stylesheet" />
<link id="prism-dark-theme" href="/themes/prism-theme-github-dark.css" media="none" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/prism.min.js"></script>

<!-- Load light and dark themes for overall layout -->
<link class="main-stylesheet" id="light-mode" rel="stylesheet" href="/css/styles.css">
<link class="main-stylesheet" id="dark-mode" rel="stylesheet" media="none" href="/css/styles-dark.css" />

<!-- Add webfont support -->
<link rel="stylesheet" href="/fonts/icons.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato&family=Merriweather&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

<script>
    function waitForElem(selector) {
        return new Promise(resolve => {
            if (document.querySelector(selector)) {
                console.log('element already exists');
                return resolve(document.querySelector(selector));
            }
    
            const observer = new MutationObserver(mutations => {
                if (document.querySelector(selector)) {
                    console.log('found element ' + selector);
                    resolve(document.querySelector(selector));
                    observer.disconnect();
                }
            });
    
            observer.observe(document.body, {
                  childList: true
                , subtree: true
                , attributes: false
                , characterData: false
            });
        });
    }
</script>

    </head>
    <body>
    <div class="container content-container">
        <header>
   <div class="header-content">
       <div class="header-center">
           <a href="/">Digital Horror</a>
       </div>
       <div class="header-right">
           <span id="dark-mode-toggle" class="mdi mdi-theme-light-dark"></span>
       </div>
   </div>
</header>



        <main>
            <article class="post">
            <h2 class="post-title">Implementing an Event Bus using Rust</h2>
            <p class="post-date">06/03/2023</p>
                <div class = "post-content"> 
                <h2><a href="#introduction" aria-hidden="true" class="anchor" id="header-introduction"></a>Introduction</h2>
<p>Lately I have been looking to learn and experiment more with lower level systems engineering projects. One of these ideas was to build a nifty little product, similar to the <a href="https://flipperzero.one/">FlipperZero</a> that acts as a fun, educational, offensive WiFi security device — the initial plan being to base it off of the Raspberry Pi 0W and combining eBPF to have a very low footprint.</p>
<p>Before digging into the network aspect of the device I decided to begin with higher level requirements and build a small framework that will enable an effective development and implementation of the device. A key requirement is the ability for different parts of the device to operate asynchronously, such as UI updates, hardware inputs, listening to network traffic as well as auxiliary functions such as logging. We need to allow for modules to operate independently while also being able to listen to what other modules are doing.</p>
<p>One common pattern that enables effective communication between these different modules is the event bus. This post aims to introduce the pattern briefly, with a concrete example<sup class="footnote-ref"><a href="#fn-1" id="fnref-1" data-footnote-ref>1</a></sup>, and how it enables this particular use-case. We will be implementing an example event bus in Rust using the <code>tokio</code> runtime, focusing on a use case where different modules within our system need to communicate with each other.</p>
<h2><a href="#event-bus-pattern" aria-hidden="true" class="anchor" id="header-event-bus-pattern"></a>Event Bus Pattern</h2>
<p>The event bus pattern provides a mechanism for different parts of a system to communicate with each other without needing to be directly connected. Modules send events to the bus and listen for events from the bus. This decouples the sender and receiver, allowing for more flexible and scalable systems. Not all event busses are the same and each type comes with its own set of tradeoffs. A non-exhaustive set of event bus types would include the following.</p>
<blockquote>
<p><strong>Note</strong> — I use channels and bus interchangeably. While there is certainly overlap, they are not exatly the time. Channels refer to the low-level construct used for thread or task communication which is what we are doing. The event bus pattern however can be applied at multiple layers with increasing degrees of abstraction.</p>
</blockquote>
<ul>
<li>Single-producer, single-consumer ()</li>
</ul>
<p>An event bus is often implemented as a publish-subscribe pattern. In this pattern, multiple publishers (modules that send events) and subscribers (modules that listen for events) can exist. Each publisher can send events to the bus, which then distributes those events to all the interested subscribers.</p>
<h2><a href="#implementing-an-event-bus-with-tokio" aria-hidden="true" class="anchor" id="header-implementing-an-event-bus-with-tokio"></a>Implementing an Event Bus with Tokio</h2>
<p>The <code>tokio</code> runtime in Rust provides the tools necessary to implement an event bus pattern. In particular, <code>tokio</code> provides a broadcast channel that is well-suited to this task. A broadcast channel allows a single sender to notify multiple receivers, which aligns perfectly with our need for a single event bus to communicate with multiple modules.</p>
<p>We implemented our <code>EventBus</code> as a wrapper around a <code>tokio::sync::broadcast</code> channel. The <code>EventBus</code> allows any module to clone it and send events, effectively acting as a publisher. On the other hand, any module can also listen for events from the <code>EventBus</code>, acting as a subscriber.</p>
<p>Here is a simplified version of our <code>EventBus</code> implementation:</p>
<pre><code class="language-rust">use tokio::sync::broadcast;

struct EventBus {
    sender: broadcast::Sender&lt;Event&gt;,
}

impl EventBus {
    fn new() -&gt; Self {
        let (sender, _) = broadcast::channel(100);

        Self { sender }
    }

    fn subscribe(&amp;self) -&gt; broadcast::Receiver&lt;Event&gt; {
        self.sender.subscribe()
    }

    fn publish(&amp;self, event: Event) {
        let _ = self.sender.send(event);
    }
}
</code></pre>
<p>In this code, <code>Event</code> is a type that represents the different kinds of events that can be sent through the event bus. The <code>new</code> function creates a new <code>EventBus</code> with a broadcast channel that can hold up to 100 events. The <code>subscribe</code> function allows a module to receive a receiver for the broadcast channel, enabling it to listen for events. The <code>publish</code> function allows a module to send an event to the event bus.</p>
<h2><a href="#conclusion" aria-hidden="true" class="anchor" id="header-conclusion"></a>Conclusion</h2>
<p>The event bus pattern provides a powerful mechanism for communication in a modular system. With Rust's <code>tokio</code> runtime, we can implement an event bus that allows for asynchronous, non-blocking communication between different modules.</p>
<p>However, there's still more to explore. The current implementation can be enhanced further by adding more sophisticated event types, better error handling, and perhaps even integrating with other asynchronous libraries and frameworks. This exploration forms the foundation for building more complex, robust and flexible systems in Rust.</p>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p><a href="https://github.com/JuxhinDB/event-bus-example/blob/main/src/main.rs">https://github.com/JuxhinDB/event-bus-example/blob/main/src/main.rs</a> <a href="#fnref-1" class="footnote-backref" data-footnote-backref aria-label="Back to content">↩</a></p>
</li>
</ol>
</section>

                </div>
            </article>
        </main>
    </div>

    <footer>
   <div class="footer-content">
       <div class="footer-center">
           &copy; 2023 Digital Horror. All rights reserved.
       </div>
       <div class="footer-right">
           <a href="https://linkedin.com/in/juxhin-db" target="_blank" rel="noopener noreferrer" class="social-icon">
               <span class="mdi mdi-linkedin"></span>
           </a>
           <a href="https://twitter.com/juxhindb" target="_blank" rel="noopener noreferrer" class="social-icon">
               <span class="mdi mdi-twitter"></span>
           </a>
           <a href="https://github.com/juxhindb" target="_blank" rel="noopener noreferrer" class="social-icon">
               <span class="mdi mdi-github"></span>
           </a>
       </div>
   </div>
</footer>



    <script src="/js/script.js" defer></script>
    <script src="/js/prism.js" defer></script>

    </body>
</html>
        